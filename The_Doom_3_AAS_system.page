The Doom 3 AAS system
=====================

|---------------------------------------------------------------------------------------------------------------------------------------------------------|
| <div id="toctitle">                                                                                                                                     
 Contents                                                                                                                                                 
 --------                                                                                                                                                 
                                                                                                                                                          
 </div>                                                                                                                                                   
 -   <span class="deadlink"><span class="tocnumber">1</span> <span class="toctext">Doom 3 AAS</span></span>                                               
     -   <span class="deadlink"><span class="tocnumber">1.1</span> <span class="toctext">Disclaimer</span></span>                                         
     -   <span class="deadlink"><span class="tocnumber">1.2</span> <span class="toctext">Credits</span></span>                                            
     -   <span class="deadlink"><span class="tocnumber">1.3</span> <span class="toctext">Overview</span></span>                                           
     -   <span class="deadlink"><span class="tocnumber">1.4</span> <span class="toctext">Creating Areas</span></span>                                     
         -   <span class="deadlink"><span class="tocnumber">1.4.1</span> <span class="toctext">Contents of volumes</span></span>                          
         -   <span class="deadlink"><span class="tocnumber">1.4.2</span> <span class="toctext">Portalisation</span></span>                                
         -   <span class="deadlink"><span class="tocnumber">1.4.3</span> <span class="toctext">Melting things together</span></span>                      
     -   <span class="deadlink"><span class="tocnumber">1.5</span> <span class="toctext">Environment Sampling</span></span>                               
         -   <span class="deadlink"><span class="tocnumber">1.5.1</span> <span class="toctext">Finding the area a player is in</span></span>              
         -   <span class="deadlink"><span class="tocnumber">1.5.2</span> <span class="toctext">Recursive subdivision by the bsp tree</span></span>        
         -   <span class="deadlink"><span class="tocnumber">1.5.3</span> <span class="toctext">Finding the areas a trace goes through</span></span>       
         -   <span class="deadlink"><span class="tocnumber">1.5.4</span> <span class="toctext">Areas a bounding box is in</span></span>                   
     -   <span class="deadlink"><span class="tocnumber">1.6</span> <span class="toctext">Reachability</span></span>                                       
     -   <span class="deadlink"><span class="tocnumber">1.7</span> <span class="toctext">Routing</span></span>                                            
         -   <span class="deadlink"><span class="tocnumber">1.7.1</span> <span class="toctext">Multi-level algorithm that calculates cache</span></span>  
         -   <span class="deadlink"><span class="tocnumber">1.7.2</span> <span class="toctext">Routing cache and Clusters</span></span>                   
         -   <span class="deadlink"><span class="tocnumber">1.7.3</span> <span class="toctext">Calculating routing caches</span></span>                   
         -   <span class="deadlink"><span class="tocnumber">1.7.4</span> <span class="toctext">Using routing caches</span></span>                         
     -   <span class="deadlink"><span class="tocnumber">1.8</span> <span class="toctext">Other stuff that could be talked about</span></span>             |

Doom 3 AAS
==========

Disclaimer
----------

The original intent of me writing all this down was to learn about the AAS system. Doom 3 is my first game programming experience and there is a lot to learn. I have found that writing it down as I go forces me to think through it in a way I normally wouldn’t. I hope it can be of use to someone and apologize for the poor organization and rough writing that follows.

Credits
-------

This entire thing is the result of me trying to understand the Area Awareness System system designed by J.M.P. van Waveren. His [thesis paper](Mr\_elusive's\_thesis) was invaluable in this process. Basically, all I did below is combine chapter 6 of the thesis with the doom 3 code. Credit goes out to him and all of id software for the kick ass games and sdk’s. Thanks JP for all the help and advice with the AAS stuff.

Overview
--------

''“The Area Awareness System (AAS) is the whole system used to provide the bot with all the information about the current state of the world. This includes information about navigation, routing and also other entities in the game. All the information is formatted and preprocessed for fast and easy access and usage by the bot. The heart of AAS is a special 3D representation of the game world. All information provided to the bot is in some way related to or linked with this 3D representation‿ ''

AAS uses 3D bounded hulls, called areas, with a specific property: the navigational complexity for traveling from any reachable point in an area to any other reachable point in the same area is minimal. … this means a player can move between any such two points by just walking or swimming along a straight line.

Of course only knowing this property of each area does not provide all the information required for routing and navigation. However, so called reachabilities between areas can be calculated. Such a reachability is created from one area to another if a player can easily travel from one area to the other. Calculating these reachabilities is not all that difficult because a lot of areas will touch each other. When two areas touch, it can easily be verified if a player can really travel from one area to the other. This does not cover all the possible reachabilities between areas, but as will be shown later on, calculating other reachabilities is sometimes more complex, but definitely possible.

The system, as it is presented here, is primarily focused on navigation and routing. However a lot of other information can be retrieved from or linked to this 3D representation.

Creating Areas
--------------

'' ‿All primitives used for collision… can now be expanded. All the space outside these expanded solid brushes is the space, where players can move around i.e. where the origin of the player bounding box can be. At this point convex hulls can be defined within this space. Within these convex hulls the player will be able to move with minimal navigational complexity. These convex hulls will become the areas of AAS‿ .''

We should look at how an area is represented in code. A file that one needs to understand well if one wants to dig into doom 3 AAS is AASFile.h. Pop it open and look for this:

` `
<font color="#339900">`// area with a boundary of faces`</font>
<font color="#0000ff">`typedef`</font>` `<font color="#0000ff">`struct`</font>` aasArea_s `<font color="#000000">`{`</font>
`   `<font color="#0000ff">`int`</font>` numFaces;              `<font color="#339900">`// number of faces used for the boundary of the area`</font>
`   `<font color="#0000ff">`int`</font>`    firstFace;          `<font color="#339900">`// first face in the face index used for the boundary of the area`</font>
`   idBounds bounds;            `<font color="#339900">`// bounds of the area`</font>
`   idVec3  center;             `<font color="#339900">`// center of the area an AI can move towards`</font>
`   `<font color="#0000ff">`unsigned`</font>` `<font color="#0000ff">`short`</font>`     flags;         `<font color="#339900">`// several area flags`</font>
`   `<font color="#0000ff">`unsigned`</font>` `<font color="#0000ff">`short`</font>`     contents;      `<font color="#339900">`// contents of the area`</font>
`   `<font color="#0000ff">`short`</font>` cluster;             `<font color="#339900">`// cluster the area belongs to, if negative it's a portal`</font>
`   `<font color="#0000ff">`short`</font>` clusterAreaNum;          `<font color="#339900">`// number of the area in the cluster`</font>
`   `<font color="#0000ff">`int`</font>`    travelFlags;            `<font color="#339900">`// travel flags for traveling through this area`</font>
`   idReachability *    reach;      `<font color="#339900">`// reachabilities that start from this area`</font>
`   idReachability *    rev_reach;  `<font color="#339900">`// reachabilities that lead to this area`</font>
<font color="#000000">`}`</font>` aasArea_t;`

An area is a convex space defined by the faces that bound it. An area keeps track of how many faces it has bounding it and the index of its first face. The actual faces are shared between areas and are stored independent of the area itself.

Areas keep track of what cluster they belong to by storing the index of that cluster. We will get into clusters and what they are soon.

Areas can be tagged with travel flags to indicate which type of travel is necessary to cross the area. Must one fly, walk, swim, etc. Travel flags are used to indicate what type of travel an AI entity can use. The flags are also declared in AASFile.h.

` `
<font color="#339900">`// travel flags`</font>
<font color="#339900">`#define TFL_INVALID          BIT(0)      // not valid                    `</font>
<font color="#339900">`#define TFL_WALK         BIT(1)      // walking                      `</font>
<font color="#339900">`#define TFL_CROUCH           BIT(2)      // crouching                    `</font>
<font color="#339900">`#define TFL_WALKOFFLEDGE     BIT(3)      // walking of a ledge           `</font>
<font color="#339900">`#define TFL_BARRIERJUMP          BIT(4)      // jumping onto a barrier       `</font>
<font color="#339900">`#define TFL_JUMP         BIT(5)      // jumping                      `</font>
<font color="#339900">`#define TFL_LADDER           BIT(6)      // climbing a ladder            `</font>
<font color="#339900">`#define TFL_SWIM         BIT(7)      // swimming                 `</font>
<font color="#339900">`#define TFL_WATERJUMP            BIT(8)      // jump out of the water        `</font>
<font color="#339900">`#define TFL_TELEPORT         BIT(9)      // teleportation                `</font>
<font color="#339900">`#define TFL_ELEVATOR         BIT(10)     // travel by elevator           `</font>
<font color="#339900">`#define TFL_FLY              BIT(11)     // fly                          `</font>
<font color="#339900">`#define TFL_SPECIAL          BIT(12)     // special                      `</font>
<font color="#339900">`#define TFL_WATER            BIT(21)     // travel through water     `</font>
<font color="#339900">`#define TFL_AIR              BIT(22)     // travel through air           `</font>

We will look at how these travel flags are compared by the routing system later.

Areas store a pointer to the first “reachability‿ in a list that is all reachabilities that lead from the area they represent to other surrounding areas. Areas also store a list of the reachabilities that lead to the area from other areas. these are stored in reach and rev\_reach. idReachability details are also coming up soon.

### Contents of volumes

*“… the contents of certain volumes is also defined with brushes. For instance a water volume is defined with a special brush. The same goes for lava and slime. These brushes that define a contents can also be expanded and compiled into the BSP tree. The leaf nodes that only contain (parts of) these brushes, that define content, can be marked as volumes with that content.*

Areas can be flagged as having contents or attributes. These flags can mean just about anything you want. The flags are used by the goal and routing algorithms. They are stored in the flags member and use bit masks to do their work. Here they are, also from idAASFile.h:

` `
<font color="#339900">`// area flags`</font>
<font color="#339900">`#define AREA_FLOOR           BIT(0)      // AI can stand on the floor in this area`</font>
<font color="#339900">`#define AREA_GAP         BIT(1)      // area has a gap                               `</font>
<font color="#339900">`#define AREA_LEDGE           BIT(2)      // if entered the AI bbox partly floats above a ledge`</font>
<font color="#339900">`#define AREA_LADDER          BIT(3)      // area contains one or more ladder faces`</font>
<font color="#339900">`#define AREA_LIQUID          BIT(4)      // area contains a liquid   `</font>
<font color="#339900">`#define AREA_CROUCH          BIT(5)      // AI cannot walk but can only crouch in this area`</font>
<font color="#339900">`#define AREA_REACHABLE_WALK      BIT(6)      // area is reachable by walking or swimming `</font>
<font color="#339900">`#define AREA_REACHABLE_FLY       BIT(7)      // area is reachable by flying                  `</font>

### Portalisation

*‿In order to calculate reachabilities and routes between areas (as will be done later on), another representation is required for the convex hulls (areas). The BSP tree does store all the information needed, but the representation cannot easily be used to calculate relations between areas. A representation with areas that are bounded by faces would be much more suitable. These faces are polygons that either represent solid walls or lead to other areas. With such a representation adjacency of areas can easily be determined, and it is easier to find or calculate geometric properties. Such a representation can be created by portalising the BSP tree. This technique creates portals between all the leaf nodes defined by the BSP tree. These portals are the faces that bound the areas‿*

We have already seen how areas store indexes to these faces. The representation of the face itself is in also in AASFile.h.

` `
<font color="#339900">`// area boundary face`</font>
<font color="#0000ff">`typedef`</font>` `<font color="#0000ff">`struct`</font>` aasFace_s `<font color="#000000">`{`</font>
`   `<font color="#0000ff">`unsigned`</font>` `<font color="#0000ff">`short`</font>`        planeNum;   `<font color="#339900">`// number of the plane this face is on`</font>
`   `<font color="#0000ff">`unsigned`</font>` `<font color="#0000ff">`short`</font>`        flags;      `<font color="#339900">`// face flags`</font>
`   `<font color="#0000ff">`int`</font>`            numEdges;   `<font color="#339900">`// number of edges in the boundary of the face`</font>
`   `<font color="#0000ff">`int`</font>`            firstEdge;  `<font color="#339900">`// first edge in the edge index`</font>
`   `<font color="#0000ff">`short`</font>`          areas`<font color="#000000">`[`</font><font color="#0000dd">`2`</font><font color="#000000">`]`</font>`;    `<font color="#339900">`// area at the front and back of this face`</font>
<font color="#000000">`}`</font>` aasFace_t;`

The definition of a face contains the data necessary to define the geometric properties of the face. It is an area on a plane bounded by edges. It also stores the index of the two areas it divides. Each face also can be tagged with flags. The flags defined in AASFile.h are listed below.

` `
<font color="#339900">`// face flags`</font>
<font color="#339900">`#define FACE_SOLID           BIT(0)      // solid at the other side                  `</font>
<font color="#339900">`#define FACE_LADDER          BIT(1)      // ladder surface                           `</font>
<font color="#339900">`#define FACE_FLOOR           BIT(2)      // standing on floor when on this face      `</font>
<font color="#339900">`#define FACE_LIQUID          BIT(3)      // face seperating two areas with liquid    `</font>
<font color="#339900">`#define FACE_LIQUIDSURFACE       BIT(4)      // face seperating liquid and air           `</font>

*‿After portalisation the basic representation needed for AAS is created. However this portalised BSP tree still needs some work and the whole representation can be optimized in several ways. The BSP tree structure is also not thrown away at this point, because it is a very useful access structure to the areas of AAS, as will be shown later on. Each area, with the face boundary representation, is linked into the BSP tree at the node that represents its convex sub-space.‿*

I will refer you to the thesis paper if you are interested in how the bsp tree is structured and created from the world space. The bsp tree is a tree of nodes which store the index of the plane that separates the two child nodes and the indexes to those children.

Here is that node definition from AASFile.h:

` `
<font color="#339900">`// nodes of the bsp tree`</font>
<font color="#0000ff">`typedef`</font>` `<font color="#0000ff">`struct`</font>` aasNode_s `<font color="#000000">`{`</font>
`   `<font color="#0000ff">`unsigned`</font>` `<font color="#0000ff">`short`</font>`     planeNum;  `<font color="#339900">`// number of the plane that splits the subspace at this node`</font>
`   `<font color="#0000ff">`int`</font>`        children`<font color="#000000">`[`</font><font color="#0000dd">`2`</font><font color="#000000">`]`</font>`; `<font color="#339900">`// child nodes, zero is solid, negative is -(area number)`</font>
<font color="#000000">`}`</font>` aasNode_t;`

Note that a negative index for one of the children represents the negation of an area number. Areas are leaf nodes on the tree that result when the space in the map is no longer divided by a plane. We will look at how the bsp tree is walked later in environment sampling to find these areas.

### Melting things together

'' “The data used for AAS is the collection of all the areas with their face boundary representation and the BSP-tree as a fast and very useful access structure to the areas. All the boundary representations of the areas will share data. The areas will share faces, edges of faces and vertices. This will allow to more easily find shared faces, edges and vertices between adjacent areas.‿ ''

This shared data is actually stored in the idAASFile class, again, declaration in AASFile.h:

` `
`class idAASFile `<font color="#000000">`{`</font>
` `
*<font color="#339900">`/*` `public` `functional` `interface` `removed` `for` `clarity` `*/`</font>*
<font color="#0000ff">`protected`</font>`:`
`   idStr               name;`
`   `<font color="#0000ff">`unsigned`</font>` `<font color="#0000ff">`int`</font>`          crc;`
` `
`   idPlaneSet          planeList;`
`   idList<aasVertex_t>       vertices;`
`   idList<aasEdge_t>     edges;`
`   idList<aasIndex_t>        edgeIndex;`
`   idList<aasFace_t>     faces;`
`   idList<aasIndex_t>        faceIndex;`
`   idList<aasArea_t>     areas;`
`   idList<aasNode_t>     nodes;`
`   idList<aasPortal_t>       portals;`
`   idList<aasIndex_t>        portalIndex;`
`   idList<aasCluster_t>      clusters;`
`   idAASSettings           settings;`
<font color="#000000">`}`</font>`;`

Environment Sampling
--------------------

'' “There are various ways to extract information from the 3D representation used for AAS. Especially the BSP tree is a very useful structure, which allows to calculate and extract certain information about the environment very easily.‿ ''

### Finding the area a player is in

'' “First of all it will be useful to know which area a bot is in. Using the BSP tree there is a very fast and easy way to calculate the area a bot is in. One can start at the root node of the BSP tree and calculate the side of the plane, stored at that node, the origin of the bot’s bounding box is at. Depending on the side of the plane the origin is at, one continues with one of the child nodes that represents either the sub-space at the front, or the sub-space at the back of the plane. At this child node one again calculates which side of the plane, stored at the child node, the origin of the bounding box is at, and one continues with one of it’s children accordingly. This procedure is continued until one of the areas of AAS is found. That area is the area the bot is situated in.‿ ''

The functionality to get the area the player or any point is in is implemented in the engine. The method signatures are declared in AASFile.h in the idAASFile class:

` `
`class idAASFile `<font color="#000000">`{`</font>
` `
*<font color="#339900">`/*` `removed` `irrelevant` `code` `*/`</font>*
` `
<font color="#0000ff">`virtual`</font>` `<font color="#0000ff">`int`</font>`  PointAreaNum`<font color="#000000">`(`</font>` `<font color="#0000ff">`const`</font>` idVec3 &origin `<font color="#000000">`)`</font>` `<font color="#0000ff">`const`</font>` = `<font color="#0000dd">`0`</font>`;`
<font color="#0000ff">`virtual`</font>` `<font color="#0000ff">`int`</font>`  PointReachableAreaNum`<font color="#000000">`(`</font>` `<font color="#0000ff">`const`</font>` idVec3 &origin, `<font color="#0000ff">`const`</font>` idBounds &searchBounds, `<font color="#0000ff">`const`</font>` `<font color="#0000ff">`int`</font>` areaFlags, `<font color="#0000ff">`const`</font>` `<font color="#0000ff">`int`</font>` excludeTravelFlags `<font color="#000000">`)`</font>` `<font color="#0000ff">`const`</font>` = `<font color="#0000dd">`0`</font>`;`
<font color="#0000ff">`virtual`</font>` `<font color="#0000ff">`int`</font>`  BoundsReachableAreaNum`<font color="#000000">`(`</font>` `<font color="#0000ff">`const`</font>` idBounds &bounds, `<font color="#0000ff">`const`</font>` `<font color="#0000ff">`int`</font>` areaFlags, `<font color="#0000ff">`const`</font>` `<font color="#0000ff">`int`</font>` excludeTravelFlags `<font color="#000000">`)`</font>` `<font color="#0000ff">`const`</font>` = `<font color="#0000dd">`0`</font>`;`
` `
*<font color="#339900">`/*` `removed` `irrelevant` `code` `*/`</font>*

PointAreaNum will return the area in the AAS system that a given point is in.

PointReachableAreaNum, well, brian from id said it best: '' “It returns the closest reachable area to the specified point. If the point is in a reachable area already, it just returns that point, otherwise (for example if the given point is outside the world or inside some geometry) it will scan the bounding box given searching for reachable areas.‿ ''

“If a point is really far outside an area (it looks like the threshold is more than 12 units in all directions), then it will return 0.‿ So the same idea as PointAreaNum, but considers whether the area is reachable in its calculations. *' TODO: BoundsReachableAreaNum isn’t used right now but describe it anyway*' It is useful to know that these same methods names appear elsewhere in the sdk.

In AAS.h the idAAS class is defined:

` `
`class idAAS `<font color="#000000">`{`</font>
*<font color="#339900">`/*` `removed` `irrelevant` `code` `*/`</font>*
` `
<font color="#339900">`// Returns the number of the area the origin is in.`</font>
<font color="#0000ff">`virtual`</font>` `<font color="#0000ff">`int`</font>`  PointAreaNum`<font color="#000000">`(`</font>` `<font color="#0000ff">`const`</font>` idVec3 &origin `<font color="#000000">`)`</font>` `<font color="#0000ff">`const`</font>` = `<font color="#0000dd">`0`</font>`;`
` `
<font color="#339900">`// Returns the number of the nearest reachable area for the given point.`</font>
<font color="#0000ff">`virtual`</font>` `<font color="#0000ff">`int`</font>`  PointReachableAreaNum`<font color="#000000">`(`</font>` `<font color="#0000ff">`const`</font>` idVec3 &origin, `<font color="#0000ff">`const`</font>` idBounds &bounds, `<font color="#0000ff">`const`</font>` `<font color="#0000ff">`int`</font>` areaFlags `<font color="#000000">`)`</font>` `<font color="#0000ff">`const`</font>` = `<font color="#0000dd">`0`</font>`;`
` `
<font color="#339900">`// Returns the number of the first reachable area in or touching the bounds.`</font>
<font color="#0000ff">`virtual`</font>` `<font color="#0000ff">`int`</font>`  BoundsReachableAreaNum`<font color="#000000">`(`</font>` `<font color="#0000ff">`const`</font>` idBounds &bounds, `<font color="#0000ff">`const`</font>` `<font color="#0000ff">`int`</font>` areaFlags `<font color="#000000">`)`</font>` `<font color="#0000ff">`const`</font>` = `<font color="#0000dd">`0`</font>`;`
` `
*<font color="#339900">`/*` `removed` `irrelevant` `code` `*/`</font>*

We will look a lot more at idAAS as we go too. The idAAS definition is an interface. The actual implementation is in the class idAASLocal defined in AAS\_local.h and implemented in AAS.cpp

` `
`class idAASLocal : `<font color="#0000ff">`public`</font>` idAAS `<font color="#000000">`{`</font>
*<font color="#339900">`/*` `removed` `irrelevant` `code` `*/`</font>*
` `
<font color="#0000ff">`virtual`</font>` `<font color="#0000ff">`int`</font>` PointAreaNum`<font color="#000000">`(`</font>` `<font color="#0000ff">`const`</font>` idVec3 &origin `<font color="#000000">`)`</font>` `<font color="#0000ff">`const`</font>`;`
<font color="#0000ff">`virtual`</font>` `<font color="#0000ff">`int`</font>` PointReachableAreaNum`<font color="#000000">`(`</font>` `<font color="#0000ff">`const`</font>` idVec3 &origin, `<font color="#0000ff">`const`</font>` idBounds &searchBounds, `<font color="#0000ff">`const`</font>` `<font color="#0000ff">`int`</font>` areaFlags `<font color="#000000">`)`</font>` `<font color="#0000ff">`const`</font>`;`
<font color="#0000ff">`virtual`</font>` `<font color="#0000ff">`int`</font>` BoundsReachableAreaNum`<font color="#000000">`(`</font>` `<font color="#0000ff">`const`</font>` idBounds &bounds, `<font color="#0000ff">`const`</font>` `<font color="#0000ff">`int`</font>` areaFlags `<font color="#000000">`)`</font>` `<font color="#0000ff">`const`</font>`;`
` `
*<font color="#339900">`/*` `removed` `irrelevant` `code` `*/`</font>*

The implementation is just a wrapper around the idAASFile implementation:

` `
*<font color="#339900">`/*` `============` `idAASLocal::PointAreaNum` `============` `*/`</font>*
<font color="#0000ff">`int`</font>` idAASLocal::`<font color="#00aabb">`PointAreaNum`</font><font color="#000000">`(`</font>` `<font color="#0000ff">`const`</font>` idVec3 &origin `<font color="#000000">`)`</font>` `<font color="#0000ff">`const`</font>` `<font color="#000000">`{`</font>
`   `<font color="#0000ff">`if`</font>` `<font color="#000000">`(`</font>` !`<font color="#0000ff">`file`</font>` `<font color="#000000">`)`</font>` `<font color="#000000">`{`</font>
`       `<font color="#0000ff">`return`</font>` `<font color="#0000dd">`0`</font>`;`
`   `<font color="#000000">`}`</font>
`   `<font color="#0000ff">`return`</font>` file->PointAreaNum`<font color="#000000">`(`</font>` origin `<font color="#000000">`)`</font>`;`
<font color="#000000">`}`</font>

PointReachableAreaNum is actually also declared in idAI in AI.h:

` `
<font color="#0000ff">`Int`</font>` PointReachableAreaNum`<font color="#000000">`(`</font>` `<font color="#0000ff">`const`</font>` idVec3 &pos, `<font color="#0000ff">`const`</font>` `<font color="#0000ff">`float`</font>` boundsScale = `<font color="#0000dd">`2`</font>`.0f `<font color="#000000">`)`</font>` `<font color="#0000ff">`const`</font>`;`

If you follow the implementation all the way back down from there you will see:

` `
*<font color="#339900">`/*` `=====================` `idAI::PointReachableAreaNum` `=====================` `*/`</font>*
<font color="#0000ff">`int`</font>` idAI::`<font color="#00aabb">`PointReachableAreaNum`</font><font color="#000000">`(`</font>` `<font color="#0000ff">`const`</font>` idVec3 &pos, `<font color="#0000ff">`const`</font>` `<font color="#0000ff">`float`</font>` boundsScale `<font color="#000000">`)`</font>` `<font color="#0000ff">`const`</font>` `<font color="#000000">`{`</font>
`   `<font color="#0000ff">`int`</font>` areaNum;`
`   idVec3 size;`
`   idBounds bounds;`
` `
`   `<font color="#0000ff">`if`</font>` `<font color="#000000">`(`</font>` !aas `<font color="#000000">`)`</font>` `<font color="#000000">`{`</font>
`       `<font color="#0000ff">`return`</font>` `<font color="#0000dd">`0`</font>`;`
`   `<font color="#000000">`}`</font>
`   `<font color="#339900">`// set up the bounding box that is used for reachability`</font>
`   size = aas->GetSettings`<font color="#000000">`(`</font><font color="#000000">`)`</font>`->boundingBoxes`<font color="#000000">`[`</font><font color="#0000dd">`0`</font><font color="#000000">`]`</font><font color="#000000">`[`</font><font color="#0000dd">`1`</font><font color="#000000">`]`</font>` * boundsScale;`
`   bounds`<font color="#000000">`[`</font><font color="#0000dd">`0`</font><font color="#000000">`]`</font>` = -size;`
`   size.`<font color="#00aabb">`z`</font>` = `<font color="#0000dd">`32`</font>`.0f;`
`   bounds`<font color="#000000">`[`</font><font color="#0000dd">`1`</font><font color="#000000">`]`</font>` = size;`
` `
`   `<font color="#0000ff">`if`</font>` `<font color="#000000">`(`</font>` move.`<font color="#00aabb">`moveType`</font>` == MOVETYPE_FLY `<font color="#000000">`)`</font>` `<font color="#000000">`{`</font>
`       areaNum = aas->PointReachableAreaNum`<font color="#000000">`(`</font>` pos, bounds, AREA_REACHABLE_WALK | AREA_REACHABLE_FLY `<font color="#000000">`)`</font>`;`
`   `<font color="#000000">`}`</font>` `<font color="#0000ff">`else`</font>` `<font color="#000000">`{`</font>
`       areaNum = aas->PointReachableAreaNum`<font color="#000000">`(`</font>` pos, bounds, AREA_REACHABLE_WALK `<font color="#000000">`)`</font>`;`
`   `<font color="#000000">`}`</font>
` `
`   `<font color="#0000ff">`return`</font>` areaNum;`
<font color="#000000">`}`</font>

At the idAI level the work of setting up the bounding boxes and travel flags is done. idAI uses its instance of pointer to idAAS to get the bounds. At some point maybe a page about AAS settings will happen.

After idAI ::PointReachableAreaNum does its work it calls AASLocal’s version of the same method.

` `
*<font color="#339900">`/*` `============` `idAASLocal::PointReachableAreaNum` `============` `*/`</font>*
<font color="#0000ff">`int`</font>` idAASLocal::`<font color="#00aabb">`PointReachableAreaNum`</font><font color="#000000">`(`</font>` `<font color="#0000ff">`const`</font>` idVec3 &origin, `<font color="#0000ff">`const`</font>` idBounds &searchBounds, `<font color="#0000ff">`const`</font>` `<font color="#0000ff">`int`</font>` areaFlags `<font color="#000000">`)`</font>` `<font color="#0000ff">`const`</font>` `<font color="#000000">`{`</font>
`   `<font color="#0000ff">`if`</font>` `<font color="#000000">`(`</font>` !`<font color="#0000ff">`file`</font>` `<font color="#000000">`)`</font>` `<font color="#000000">`{`</font>
`       `<font color="#0000ff">`return`</font>` `<font color="#0000dd">`0`</font>`;`
`   `<font color="#000000">`}`</font>
` `
`   `<font color="#0000ff">`return`</font>` file->PointReachableAreaNum`<font color="#000000">`(`</font>` origin, searchBounds, areaFlags, TFL_INVALID `<font color="#000000">`)`</font>`;`
<font color="#000000">`}`</font>

Which is just a wrapper around idAASFile’s version, passing in the TFL\_INVALID flag for excluded travel flags.

### Recursive subdivision by the bsp tree

**TODO**

### Finding the areas a trace goes through

**Code dump for tracing. TODO**

` `
<font color="#0000ff">`virtual`</font>` `<font color="#0000ff">`bool`</font>` Trace`<font color="#000000">`(`</font>` aasTrace_t &trace, `<font color="#0000ff">`const`</font>` idVec3 &start, `<font color="#0000ff">`const`</font>` idVec3 &end `<font color="#000000">`)`</font>` `<font color="#0000ff">`const`</font>` = `<font color="#0000dd">`0`</font>`;`

` `
<font color="#339900">`// trace through the world`</font>
<font color="#0000ff">`typedef`</font>` `<font color="#0000ff">`struct`</font>` aasTrace_s `<font color="#000000">`{`</font>
`                   `<font color="#339900">`// parameters`</font>
`   `<font color="#0000ff">`int`</font>`                flags;          `<font color="#339900">`// areas with these flags block the trace`</font>
`   `<font color="#0000ff">`int`</font>`                travelFlags;        `<font color="#339900">`// areas with these travel flags block the trace`</font>
`   `<font color="#0000ff">`int`</font>`                maxAreas;       `<font color="#339900">`// size of the 'areas' array`</font>
`   `<font color="#0000ff">`int`</font>`                getOutOfSolid;      `<font color="#339900">`// trace out of solid if the trace starts in solid`</font>
`                   `<font color="#339900">`// output`</font>
`   `<font color="#0000ff">`float`</font>`              fraction;       `<font color="#339900">`// fraction of trace completed`</font>
`   idVec3              endpos;         `<font color="#339900">`// end position of trace`</font>
`   `<font color="#0000ff">`int`</font>`                planeNum;       `<font color="#339900">`// plane hit`</font>
`   `<font color="#0000ff">`int`</font>`                lastAreaNum;        `<font color="#339900">`// number of last area the trace went through`</font>
`   `<font color="#0000ff">`int`</font>`                blockingAreaNum;    `<font color="#339900">`// area that could not be entered`</font>
`   `<font color="#0000ff">`int`</font>`                numAreas;       `<font color="#339900">`// number of areas the trace went through`</font>
`   `<font color="#0000ff">`int`</font>` *              areas;          `<font color="#339900">`// array to store areas the trace went through`</font>
`   idVec3 *            points;         `<font color="#339900">`// points where the trace entered each new area`</font>
`                   aasTrace_s`<font color="#000000">`(`</font>` `<font color="#0000ff">`void`</font>` `<font color="#000000">`)`</font>` `<font color="#000000">`{`</font>` areas = `<font color="#0000ff">`NULL`</font>`; points = `<font color="#0000ff">`NULL`</font>`; getOutOfSolid = `<font color="#0000ff">`false`</font>`; flags = travelFlags = maxAreas = `<font color="#0000dd">`0`</font>`; `<font color="#000000">`}`</font>
<font color="#000000">`}`</font>` aasTrace_t;`

'' “idAASFile::Trace actually allows you to get an ordered list of all areas the a line goes through if you set aasTrace\_t::areas to an integer array and aasTrace\_t::maxAreas to the maximum number of elements in this array. The array will be filled in with the numbers of the areas the line went through and aasTrace\_t::numAreas will be set to the number of areas.‿ ''

### Areas a bounding box is in

'' “In order to calculate if the bot’s bounding box can or will touch the bounding boxes of other entities in the world, it is often useful to know in which area(s) the bounding boxes of entities are. To calculate this the bounding box of the entity has to be expanded, just like the brushes are expanded for collision calculations. This expansion is necessary, because the not expanded bounding box can be outside all areas, when at the same time the bot might be able to touch the bounding box while standing in a certain area. After expansion it can be calculated in which area(s) the bounding box resides, by testing on which side of the BSP tree split planes the bounding box is situated. This works similar to how the area a bot is in, is found. However a bounding box is now used instead of a point‿ ''

Side Note:You can use BoundsReachableAreaNum to return the number of the first reachable area in or touching the bounds you pass to it.

However if you want a list of the areas as described above you will have to take a look at idAASLocal::GetBoundsAreas\_r. Before we look at it lets look at how it is used. The only place that it is called in the sdk is from idAASLocal::AddObstacle. The only thing to note from AddObstacle for now is how the bounds passed to GetBoundsArea\_r are expanded and how the root node, 1, is passed to the GetBoundsAreas\_r. We will get into how obstacles are used later.

` `
*<font color="#339900">`/*` `============` `idAASLocal::AddObstacle` `============` `*/`</font>*
`aasHandle_t idAASLocal::`<font color="#00aabb">`AddObstacle`</font><font color="#000000">`(`</font>` `<font color="#0000ff">`const`</font>` idBounds &bounds `<font color="#000000">`)`</font>` `<font color="#000000">`{`</font>
`   idRoutingObstacle *obstacle;`
` `
`   `<font color="#0000ff">`if`</font>` `<font color="#000000">`(`</font>` !`<font color="#0000ff">`file`</font>` `<font color="#000000">`)`</font>` `<font color="#000000">`{`</font>
`       `<font color="#0000ff">`return`</font>` -`<font color="#0000dd">`1`</font>`;`
`   `<font color="#000000">`}`</font>
` `
`   obstacle = `<font color="#0000dd">`new`</font>` idRoutingObstacle;`
`   obstacle->bounds`<font color="#000000">`[`</font><font color="#0000dd">`0`</font><font color="#000000">`]`</font>` = bounds`<font color="#000000">`[`</font><font color="#0000dd">`0`</font><font color="#000000">`]`</font>` - file->GetSettings`<font color="#000000">`(`</font><font color="#000000">`)`</font>`.`<font color="#00aabb">`boundingBoxes`</font><font color="#000000">`[`</font><font color="#0000dd">`0`</font><font color="#000000">`]`</font><font color="#000000">`[`</font><font color="#0000dd">`1`</font><font color="#000000">`]`</font>`;`
`   obstacle->bounds`<font color="#000000">`[`</font><font color="#0000dd">`1`</font><font color="#000000">`]`</font>` = bounds`<font color="#000000">`[`</font><font color="#0000dd">`1`</font><font color="#000000">`]`</font>` - file->GetSettings`<font color="#000000">`(`</font><font color="#000000">`)`</font>`.`<font color="#00aabb">`boundingBoxes`</font><font color="#000000">`[`</font><font color="#0000dd">`0`</font><font color="#000000">`]`</font><font color="#000000">`[`</font><font color="#0000dd">`0`</font><font color="#000000">`]`</font>`;`
`   GetBoundsAreas_r`<font color="#000000">`(`</font>` `<font color="#0000dd">`1`</font>`, obstacle->bounds, obstacle->areas `<font color="#000000">`)`</font>`;`
`   SetObstacleState`<font color="#000000">`(`</font>` obstacle, `<font color="#0000ff">`true`</font>` `<font color="#000000">`)`</font>`;`
` `
`   obstacleList.`<font color="#00aabb">`Append`</font><font color="#000000">`(`</font>` obstacle `<font color="#000000">`)`</font>`;`
`   `<font color="#0000ff">`return`</font>` obstacleList.`<font color="#00aabb">`Num`</font><font color="#000000">`(`</font><font color="#000000">`)`</font>` - `<font color="#0000dd">`1`</font>`;`
<font color="#000000">`}`</font>

Now for the actual routine. '' “One starts at the root node of the BSP tree and calculates which side of the plane, stored at that node, the bounding box is at.‿ ''

` `
*<font color="#339900">`/*` `============` `idAASLocal::GetBoundsAreas_r` `============` `*/`</font>*
<font color="#0000ff">`void`</font>` idAASLocal::`<font color="#00aabb">`GetBoundsAreas_r`</font><font color="#000000">`(`</font>` `<font color="#0000ff">`int`</font>` nodeNum, `<font color="#0000ff">`const`</font>` idBounds &bounds, idList<int> &areas `<font color="#000000">`)`</font>` `<font color="#0000ff">`const`</font>` `<font color="#000000">`{`</font>
`   `<font color="#0000ff">`int`</font>` res;`
`   `<font color="#0000ff">`const`</font>` aasNode_t *node;`
` `
`   `<font color="#0000ff">`while`</font><font color="#000000">`(`</font>` nodeNum != `<font color="#0000dd">`0`</font>` `<font color="#000000">`)`</font>` `<font color="#000000">`{`</font>
` `

'' “This procedure is continued until all the areas of AAS the bounding box is in are found.‿ ''

` `
`       `<font color="#0000ff">`if`</font>` `<font color="#000000">`(`</font>` nodeNum < `<font color="#0000dd">`0`</font>` `<font color="#000000">`)`</font>` `<font color="#000000">`{`</font>
`           areas.`<font color="#00aabb">`Append`</font><font color="#000000">`(`</font>` -nodeNum `<font color="#000000">`)`</font>`;`
`           `<font color="#0000ff">`break`</font>`;`
`       `<font color="#000000">`}`</font>

To understand the check above it helps to understand how the bsp tree we are navigating was built. It is quite a bit of reading, and I don’t have code to annotate for it, so I will again refer you to chapter 6 in [Mr\_elusive's\_thesis](Mr\_elusive's\_thesis). The routine checks if the nodeNum is negative. It does this because nodes that have negative indexes are leaf nodes. So, when we find a negative nodeNum, we know we have found a leaf node that our bounds is in. We append the area index to the list passed in to be populated and break out of the loop.

If the nodeNum isn’t negative, we have to keep searching…

“Depending on the side of the plane the bounding box is at one continues with one of the child nodes, that represents either the sub-space at the front or the sub-space at the back of the plane. \</i\>

` `
`       node = &file->GetNode`<font color="#000000">`(`</font>` nodeNum `<font color="#000000">`)`</font>`;`
`       res = bounds.`<font color="#00aabb">`PlaneSide`</font><font color="#000000">`(`</font>` file->GetPlane`<font color="#000000">`(`</font>` node->planeNum `<font color="#000000">`)`</font>` `<font color="#000000">`)`</font>`;`
`       `<font color="#0000ff">`if`</font>` `<font color="#000000">`(`</font>` res == PLANESIDE_BACK `<font color="#000000">`)`</font>` `<font color="#000000">`{`</font>
`           nodeNum = node->children`<font color="#000000">`[`</font><font color="#0000dd">`1`</font><font color="#000000">`]`</font>`;`
`       `<font color="#000000">`}`</font>
`       `<font color="#0000ff">`else`</font>` `<font color="#0000ff">`if`</font>` `<font color="#000000">`(`</font>` res == PLANESIDE_FRONT `<font color="#000000">`)`</font>` `<font color="#000000">`{`</font>
`           nodeNum = node->children`<font color="#000000">`[`</font><font color="#0000dd">`0`</font><font color="#000000">`]`</font>`;`
`       `<font color="#000000">`}`</font>

We find out which side of the splitting plane the bounding box is on and set the nodeNum to the child that represents that side of the plane for the next iteration through the loop.

'' “In case the plane stored at the node splits the bounding box one continues with both children. ''

` `
`       `<font color="#0000ff">`else`</font>` `<font color="#000000">`{`</font>
`           GetBoundsAreas_r`<font color="#000000">`(`</font>` node->children`<font color="#000000">`[`</font><font color="#0000dd">`1`</font><font color="#000000">`]`</font>`, bounds, areas `<font color="#000000">`)`</font>`;`
`           nodeNum = node->children`<font color="#000000">`[`</font><font color="#0000dd">`0`</font><font color="#000000">`]`</font>`;`
`       `<font color="#000000">`}`</font>
`   `<font color="#000000">`}`</font>
<font color="#000000">`}`</font>

By calling GetBoundsAreas\_r recursively we are able to divide the search down two branches of the tree.

'' “At each child node one again calculates which side of the plane, stored at the child node, the bounding box is at, and one continues with one or both of it’s children accordingly.‿ '' In other words back to the top of the while loop.

Reachability
------------

'' “Just the area representations are not sufficient for the bot to travel through the whole map. The bot will need to know how to travel from one area to the other, if possible at all. Therefore so-called reachabilities between areas are calculated. Such a reachability always starts in a certain area and leads to one other area. All possible reachabilities can be classified using about 12 different types...‿ ''

- Swimming in a straight line - Walking in a straight line - Crouching in a straight line - Jumping onto a barrier - Walking of a ledge - Jumping out of the water - Jumping - Teleporting - Using an elevator - Using a jump pad - Using a bobbing platform - Rocket jumping

Currently in doom 3 however: '' “The Doom3 AAS compiler finds the following reachabilities: ''

TFL\_WALK TFL\_BARRIERJUMP TFL\_WALKOFFLEDGE TFL\_SWIM TFL\_WATERJUMP TFL\_FLY

although the swim and fly reachabilities are only calculated if in the AAS settings "allowSwimReachabilities" and "allowFlyReachabilities" are set respectively. There tend to be a lot of fly reachabilities so we don't waste memory to store them if there are no flying creatures in a level.

Since the Doom3 AAS format is very open and the environment sampling functionality is exposed through idAASFile as well it shouldn't be too hard for third parties to write a tool that adds more reachabilities to an AAS file.‿ The task of extending the AAS as described is underway; you can read about it over [here](Extending\_the\_Area\_Awareness\_System).

idReachability is the class used to represent reachabilities in code. Its definition can be found in AASFile.h.

` `
<font color="#339900">`// reachability to another area`</font>
`class idReachability `<font color="#000000">`{`</font>
<font color="#0000ff">`public`</font>`:`
`   `<font color="#0000ff">`int`</font>`                    travelType;     `<font color="#339900">`// type of travel required to get to the area`</font>
`   `<font color="#0000ff">`short`</font>`                  toAreaNum;      `<font color="#339900">`// number of the reachable area`</font>
`   `<font color="#0000ff">`short`</font>`                  fromAreaNum;        `<font color="#339900">`// number of area the reachability starts`</font>
`   idVec3                  start;          `<font color="#339900">`// start point of inter area movement`</font>
`   idVec3                  end;            `<font color="#339900">`// end point of inter area movement`</font>
`   `<font color="#0000ff">`int`</font>`                    edgeNum;        `<font color="#339900">`// edge crossed by this reachability`</font>
`   `<font color="#0000ff">`unsigned`</font>` `<font color="#0000ff">`short`</font>`                travelTime;     `<font color="#339900">`// travel time of the inter area movement`</font>
`   byte                    number;         `<font color="#339900">`// reachability number within the fromAreaNum (must be < 256)`</font>
`   byte                    disableCount;       `<font color="#339900">`// number of times this reachability has been disabled`</font>
`   idReachability *            next;           `<font color="#339900">`// next reachability in list`</font>
`   idReachability *            rev_next;       `<font color="#339900">`// next reachability in reversed list`</font>
`   `<font color="#0000ff">`unsigned`</font>` `<font color="#0000ff">`short`</font>` *          areaTravelTimes;    `<font color="#339900">`// travel times within the fromAreaNum from reachabilities that lead towards this area`</font>
<font color="#0000ff">`public`</font>`:`
`   `<font color="#0000ff">`void`</font>`                   CopyBase`<font color="#000000">`(`</font>` idReachability &reach `<font color="#000000">`)`</font>`;`
<font color="#000000">`}`</font>`;`

The first data member is travelType, this will hold the travel flags we looked at earlier. In this case it represents the type of travel necessary to use the reachability to get to the next area. A reachability connects the area in the map indexed as fromAreaNum to the area in the map indexed as toAreaNum. start and end represent the actual location the reachability starts and ends as a position vector. To get from one area to another you typically cross an edge that is shared between the two areas, the index of that edge is stored in edgeNum. Reachabilities are weighted so the routing algorithm can find the least cost path. That weight is stored in travelTime. Each reachability gets an index that represents the reachability in the area. This index is used by the routing system as we will see later. Dynamic obstacles may be added to the AAS system during game play. These obstacles may effectively block reachabilities from being used, disableCount tracks this occurrence.

Remember the definition for area, a pointer to a reachability is used to store all reachabilities for a given direction.

` `
`   idReachability *            reach;              `<font color="#339900">`// reachabilities that start from this area`</font>
`   idReachability *            rev_reach;          `<font color="#339900">`// reachabilities that lead to this area`</font>
<font color="#000000">`}`</font>` aasArea_t;`

idReachabilities are linked into areas in two lists. The reach pointer above points to the first reachability that starts in the area defined and ends in another area.The idReachability pointer “next‿ points to the next reachability in this list. Each reachability that leads from the area to another area is added to this list when the idAASFile is loaded. The same is true for rev\_reach and rev\_next, only for reachabilities that lead to the area are stored instead. The routing system uses the graph formed by the areas and reachabilities to search for least cost paths from one location to another. We will look at this in depth later. The areaTravelTimes member of idReachability is an array of travel times across an area from other reachabilities that lead towards the area the reachability ends in. These travel times are calculated when the AAS system is initialized for quick lookup later by the routing system.

Routing
-------

### Multi-level algorithm that calculates cache

'' “The routing algorithm always calculates and caches routing data for a specific goal area. The routing cache stores per goal area, the travel times of areas towards this goal, and the first reachability to be used from these areas towards this goal..‿ '' This routing data is stored within idAASLocal which is declared in AAS\_local.h:

` `
`class idAASLocal : `<font color="#0000ff">`public`</font>` idAAS `<font color="#000000">`{`</font>
` `
*<font color="#339900">`/*` `removed` `unrelated` `code` `*/`</font>*
` `
<font color="#0000ff">`private`</font>`:  `<font color="#339900">`// routing data`</font>
`   idRoutingCache ***      areaCacheIndex;     `<font color="#339900">`// for each area in each cluster the travel times to all other areas in the cluster`</font>
`   `<font color="#0000ff">`int`</font>`                areaCacheIndexSize; `<font color="#339900">`// number of area cache entries`</font>
`   idRoutingCache **       portalCacheIndex;   `<font color="#339900">`// for each area in the world the travel times from each portal`</font>
`   `<font color="#0000ff">`int`</font>`                portalCacheIndexSize;   `<font color="#339900">`// number of portal cache entries`</font>
`   idRoutingUpdate *       areaUpdate;     `<font color="#339900">`// memory used to update the area routing cache`</font>
`   idRoutingUpdate *       portalUpdate;       `<font color="#339900">`// memory used to update the portal routing cache`</font>
`   `<font color="#0000ff">`unsigned`</font>` `<font color="#0000ff">`short`</font>` *      goalAreaTravelTimes;    `<font color="#339900">`// travel times to goal areas`</font>
`   `<font color="#0000ff">`unsigned`</font>` `<font color="#0000ff">`short`</font>` *      areaTravelTimes;    `<font color="#339900">`// travel times through the areas`</font>
`   `<font color="#0000ff">`int`</font>`                numAreaTravelTimes; `<font color="#339900">`// number of area travel times`</font>
`   mutable idRoutingCache *    cacheListStart;     `<font color="#339900">`// start of list with cache sorted from oldest to newest`</font>
`   mutable idRoutingCache *    cacheListEnd;       `<font color="#339900">`// end of list with cache sorted from oldest to newest`</font>
`   mutable `<font color="#0000ff">`int`</font>`            totalCacheMemory;   `<font color="#339900">`// total cache memory used`</font>
`   idList<idRoutingObstacle *>   obstacleList;       `<font color="#339900">`// list with obstacles `</font>

If some of these declarations seem unclear don’t worry, we will look at when and how this data is set up soon.

Much of the data above is stored in a class named idRoutingCache, it is declared in the same file.

` `
`class idRoutingCache `<font color="#000000">`{`</font>
`   `<font color="#0000ff">`friend`</font>` class idAASLocal;`
` `
<font color="#0000ff">`public`</font>`:`
`                   idRoutingCache`<font color="#000000">`(`</font>` `<font color="#0000ff">`int`</font>` size `<font color="#000000">`)`</font>`;`
`                   ~idRoutingCache`<font color="#000000">`(`</font>` `<font color="#0000ff">`void`</font>` `<font color="#000000">`)`</font>`;`
` `
`   `<font color="#0000ff">`int`</font>`                Size`<font color="#000000">`(`</font>` `<font color="#0000ff">`void`</font>` `<font color="#000000">`)`</font>` `<font color="#0000ff">`const`</font>`;`
` `
<font color="#0000ff">`private`</font>`:`
`   `<font color="#0000ff">`int`</font>`                type;           `<font color="#339900">`// portal or area cache`</font>
`   `<font color="#0000ff">`int`</font>`                size;           `<font color="#339900">`// size of cache`</font>
`   `<font color="#0000ff">`int`</font>`                cluster;        `<font color="#339900">`// cluster of the cache`</font>
`   `<font color="#0000ff">`int`</font>`                areaNum;        `<font color="#339900">`// area of the cache`</font>
`   `<font color="#0000ff">`int`</font>`                travelFlags;        `<font color="#339900">`// combinations of the travel flags`</font>
`   idRoutingCache *        next;           `<font color="#339900">`// next in list`</font>
`   idRoutingCache *        prev;           `<font color="#339900">`// previous in list`</font>
`   idRoutingCache *        time_next;      `<font color="#339900">`// next in time based list`</font>
`   idRoutingCache *        time_prev;      `<font color="#339900">`// previous in time based list`</font>
`   `<font color="#0000ff">`unsigned`</font>` `<font color="#0000ff">`short`</font>`            startTravelTime;    `<font color="#339900">`// travel time to start with`</font>
`   `<font color="#0000ff">`unsigned`</font>` `<font color="#0000ff">`char`</font>` *           reachabilities;     `<font color="#339900">`// reachabilities used for routing`</font>
`   `<font color="#0000ff">`unsigned`</font>` `<font color="#0000ff">`short`</font>` *      travelTimes;        `<font color="#339900">`// travel time for every area`</font>
<font color="#000000">`}`</font>`;`

Notice how each instance will store the area number and travel flags it was created for and as mentioned in the quote above, will store the travel times and first reachability to be used from each area towards the goal area. We will take a look at how idRoutingCache objects are created and linked into the routing cache in detail in a bit.

Before that, let’s see how the system is initialized when a map loads. In idGameLocal::LoadMap:

` `
<font color="#339900">`// load navigation system for all the different monster sizes`</font>
`   `<font color="#0000ff">`for`</font><font color="#000000">`(`</font>` i = `<font color="#0000dd">`0`</font>`; i < aasNames.`<font color="#00aabb">`Num`</font><font color="#000000">`(`</font><font color="#000000">`)`</font>`; i++ `<font color="#000000">`)`</font>` `<font color="#000000">`{`</font>
`       aasList`<font color="#000000">`[`</font>` i `<font color="#000000">`]`</font>`->Init`<font color="#000000">`(`</font>` idStr`<font color="#000000">`(`</font>` mapFileName `<font color="#000000">`)`</font>`.`<font color="#00aabb">`SetFileExtension`</font><font color="#000000">`(`</font>` aasNames`<font color="#000000">`[`</font>` i `<font color="#000000">`]`</font>` `<font color="#000000">`)`</font>`.`<font color="#00aabb">`c_str`</font><font color="#000000">`(`</font><font color="#000000">`)`</font>`, mapFile->GetGeometryCRC`<font color="#000000">`(`</font><font color="#000000">`)`</font>` `<font color="#000000">`)`</font>`;`
`   `<font color="#000000">`}`</font>

Each size AAS file that exists for the given map is initialized. The initialization code is idAASLocal::Init:

` `
*<font color="#339900">`/*` `============` `idAASLocal::Init` `============` `*/`</font>*
<font color="#0000ff">`bool`</font>` idAASLocal::`<font color="#00aabb">`Init`</font><font color="#000000">`(`</font>` `<font color="#0000ff">`const`</font>` idStr &mapName, `<font color="#0000ff">`unsigned`</font>` `<font color="#0000ff">`int`</font>` mapFileCRC `<font color="#000000">`)`</font>` `<font color="#000000">`{`</font>
`   `<font color="#0000ff">`if`</font>` `<font color="#000000">`(`</font>` `<font color="#0000ff">`file`</font>` && mapName.`<font color="#00aabb">`Icmp`</font><font color="#000000">`(`</font>` file->GetName`<font color="#000000">`(`</font><font color="#000000">`)`</font>` `<font color="#000000">`)`</font>` == `<font color="#0000dd">`0`</font>` && mapFileCRC == file->GetCRC`<font color="#000000">`(`</font><font color="#000000">`)`</font>` `<font color="#000000">`)`</font>` `<font color="#000000">`{`</font>
`       common->Printf`<font color="#000000">`(`</font>` `<font color="#666666">`"Keeping %s`**<font color="#666666">`\n`</font>**`"`</font>`, file->GetName`<font color="#000000">`(`</font><font color="#000000">`)`</font>` `<font color="#000000">`)`</font>`;`
`       RemoveAllObstacles`<font color="#000000">`(`</font><font color="#000000">`)`</font>`;`
`   `<font color="#000000">`}`</font>
`   `<font color="#0000ff">`else`</font>` `<font color="#000000">`{`</font>
`       Shutdown`<font color="#000000">`(`</font><font color="#000000">`)`</font>`;`
` `
`       `<font color="#0000ff">`file`</font>` = AASFileManager->LoadAAS`<font color="#000000">`(`</font>` mapName, mapFileCRC `<font color="#000000">`)`</font>`;`
`       `<font color="#0000ff">`if`</font>` `<font color="#000000">`(`</font>` !`<font color="#0000ff">`file`</font>` `<font color="#000000">`)`</font>` `<font color="#000000">`{`</font>
`           common->DWarning`<font color="#000000">`(`</font>` `<font color="#666666">`"Couldn't load AAS file: '%s'"`</font>`, mapName.`<font color="#00aabb">`c_str`</font><font color="#000000">`(`</font><font color="#000000">`)`</font>` `<font color="#000000">`)`</font>`;`
`           `<font color="#0000ff">`return`</font>` `<font color="#0000ff">`false`</font>`;`
`       `<font color="#000000">`}`</font>
`       SetupRouting`<font color="#000000">`(`</font><font color="#000000">`)`</font>`;`
`   `<font color="#000000">`}`</font>
`   `<font color="#0000ff">`return`</font>` `<font color="#0000ff">`true`</font>`;`
<font color="#000000">`}`</font>

AASFileManager-\>LoadAAS loads the .aas file into an instance of idAASFile. We looked at idAASFile and its lists of data earlier. After the area and reachability information is loaded into memory from the file SetupRouting is called.

` `
*<font color="#339900">`/*` `============` `idAASLocal::SetupRouting` `============` `*/`</font>*
<font color="#0000ff">`bool`</font>` idAASLocal::`<font color="#00aabb">`SetupRouting`</font><font color="#000000">`(`</font>` `<font color="#0000ff">`void`</font>` `<font color="#000000">`)`</font>` `<font color="#000000">`{`</font>
`   CalculateAreaTravelTimes`<font color="#000000">`(`</font><font color="#000000">`)`</font>`;`
`   SetupRoutingCache`<font color="#000000">`(`</font><font color="#000000">`)`</font>`;`
`   `<font color="#0000ff">`return`</font>` `<font color="#0000ff">`true`</font>`;`
<font color="#000000">`}`</font>

CalculateAreaTravelTimes initializes the areaTravelTime array of each reachability in the map. It also calculates and sets the maxAreaTravelTime for any portal areas. We will see these travel times used later. SetupRoutingCache initializes memory for all the routing cache data members we looked at earlier. If anyone would like more detail on these just ask.

### Routing cache and Clusters

'' “The multi-level routing algorithm calculates routing caches at two levels. It calculates cache for areas in a cluster and it calculates cache for cluster portals. In a map one or more clusters with areas are created. Such a cluster is a group of connected areas. Shared bounding faces and reachabilities connect the areas. The clusters are separated by cluster portals, which are areas themselves. The only way to travel from one cluster to another is through one or more cluster portals. A cluster portal always separates no more and no less than two clusters. The cache for areas in a cluster will be called area cache, and the cache for cluster portals, portal cache. The area cache stores the travel times of all areas within a cluster, including the cluster portal areas that touch the cluster, towards goal areas that are in the same cluster. The portal cache stores the travel times of all portal areas in a map, towards a goal area which can be anywhere on the map. Such a goal area can be any area from any cluster, including cluster portal areas.‿ ''

Yeah, so if you didn’t quite catch that, you probably want to read it again before moving into the code that does it. Maybe I will upload a picture too someday.

First we will look again at a couple of declarations from above, they should make a little more sense now. An area cache and a portal cache to store routing data at two different levels.

` `
`idRoutingCache *** areaCacheIndex;         `
`idRoutingCache **  portalCacheIndex;`

Lets look at portalCacheIndex first. It is a pointer to a dynamically allocated array of pointers to idRoutingCaches. The array is indexed by goal area number. You will see it used later like this:

` `
<font color="#0000ff">`else`</font>` `<font color="#0000ff">`if`</font>` `<font color="#000000">`(`</font>` cache->type == CACHETYPE_PORTAL `<font color="#000000">`)`</font>` `<font color="#000000">`{`</font>
`       portalCacheIndex`<font color="#000000">`[`</font>`cache->areaNum`<font color="#000000">`]`</font>` = cache->next;`
`   `<font color="#000000">`}`</font>

The neat part is the idRoutingCache pointed to by each area index is that it is actually part of a doubly linked list of idRoutingCaches. An instance is added to this list for each for each distinct set of travel flags requested for the area by the routing algorithm. So you will see loops like this later.

` `
<font color="#339900">`// check if cache without undesired travel flags already exists`</font>
`   `<font color="#0000ff">`for`</font>` `<font color="#000000">`(`</font>` cache = portalCacheIndex`<font color="#000000">`[`</font>`areaNum`<font color="#000000">`]`</font>`; cache; cache = cache->next `<font color="#000000">`)`</font>` `<font color="#000000">`{`</font>
`       `<font color="#0000ff">`if`</font>` `<font color="#000000">`(`</font>` cache->travelFlags == travelFlags `<font color="#000000">`)`</font>` `<font color="#000000">`{`</font>
`           `<font color="#0000ff">`break`</font>`;`
`       `<font color="#000000">`}`</font>
`   `<font color="#000000">`}`</font>

Ok, got that. One more time, a pointer to an array of pointers to doubly linked lists of idRoutingCaches, indexed per goal area, linked per travel flags. he he, you remember what it is for now? me either, here:

'' “The portal cache stores the travel times of all portal areas in a map, towards a goal area which can be anywhere on the map. Such a goal area can be any area from any cluster, including cluster portal areas.‿ ''

Good, now lets look at areaCacheIndex. Again, for reference:

` `
`idRoutingCache *** areaCacheIndex;`

areaCacheIndex is a pointer to a dynamically allocated two dimensional array of pointers to idRoutingCaches. The first dimension of the array is indexed by cluster number. The second dimension is indexed by area number. Perhaps an example:

` `
<font color="#339900">`// pointer to the cache for the area in the cluster`</font>
`   clusterCache = areaCacheIndex`<font color="#000000">`[`</font>`clusterNum`<font color="#000000">`]`</font><font color="#000000">`[`</font>`clusterAreaNum`<font color="#000000">`]`</font>`;`

Try to think of it this way. What you have is an array of caches that represent the routing data for each cluster in the map. Clusters contain areas, so a clusters routing data is itself an array of routing data for areas.

Or maybe this way?

A pointer to an array (indexed by cluster number) of arrays (each indexed by area number) of pointers to idRoutingCaches which represent the routing data for that area in that cluster. And don’t forget, idRoutingCaches are themselves doubly linked lists with a link for each set of travel flags passed in by the routing algorithm.

Well, if it isn’t clear now, maybe it will be after we see it being used, and remember:

'' “The area cache stores the travel times of all areas within a cluster, including the cluster portal areas that touch the cluster, towards goal areas that are in the same cluster.‿ ''

Moving on…

'' “In general not all routing cache will be calculated. Routing cache will only be calculated and stored for areas the bot has had, or still has as a goal.‿ ''

We now know that there are actually two levels to the cache, a level for areas and a level for clusters. There are also two corresponding methods to get at this data for each level. GetAreaRoutingCache and GetPortalRoutingCache. We will look at GetAreaRoutingCache in detail and skip GetPortalRoutingCache as it is almost identical.

GetAreaRoutingCache is called, passing in the cluster, area, and travel flags you would like routing data for. GetAreaRoutingCache checks to see if the appropriate data is already cached. If not, it creates it, caches it, then returns it.

` `
*<font color="#339900">`/*` `============` `idAASLocal::GetAreaRoutingCache` `============` `*/`</font>*
`idRoutingCache *idAASLocal::`<font color="#00aabb">`GetAreaRoutingCache`</font><font color="#000000">`(`</font>` `<font color="#0000ff">`int`</font>` clusterNum, `<font color="#0000ff">`int`</font>` areaNum, `<font color="#0000ff">`int`</font>` travelFlags `<font color="#000000">`)`</font>` `<font color="#0000ff">`const`</font>` `<font color="#000000">`{`</font>
`   `<font color="#0000ff">`int`</font>` clusterAreaNum;`
`   idRoutingCache *cache, *clusterCache;`

If the area passed in is a cluster portal area (one of those that separate clusters) than the area actually belongs to two different clusters (the two it separates). It will have two different indexes, one that identifies it in each cluster. Areas are stored in an instance of idList in an idAASFile. The index of the area into this list is different then the index of the area that identifies it in a cluster. The call below to ClusterAreaNum returns the area number that represents the area in the cluster we asked for.

` `
`   `<font color="#339900">`// number of the area in the cluster`</font>
`   clusterAreaNum = ClusterAreaNum`<font color="#000000">`(`</font>` clusterNum, areaNum `<font color="#000000">`)`</font>`;`

We can now get the idRoutingCache object for the area and iterate through the linked list to find one that has the appropriate travel flags.

` `
` `
`   `<font color="#339900">`// pointer to the cache for the area in the cluster`</font>
`   clusterCache = areaCacheIndex`<font color="#000000">`[`</font>`clusterNum`<font color="#000000">`]`</font><font color="#000000">`[`</font>`clusterAreaNum`<font color="#000000">`]`</font>`;`
`   `<font color="#339900">`// check if cache without undesired travel flags already exists`</font>
`   `<font color="#0000ff">`for`</font>` `<font color="#000000">`(`</font>` cache = clusterCache; cache; cache = cache->next `<font color="#000000">`)`</font>` `<font color="#000000">`{`</font>
`       `<font color="#0000ff">`if`</font>` `<font color="#000000">`(`</font>` cache->travelFlags == travelFlags `<font color="#000000">`)`</font>` `<font color="#000000">`{`</font>
`           `<font color="#0000ff">`break`</font>`;`
`       `<font color="#000000">`}`</font>
`   `<font color="#000000">`}`</font>

If we didn’t find a cache object, either because there wasn’t one for the area at all, or there wasn’t one with the appropriate flags, GetAreaRoutingCache will create it and insert it as the first node in the linked list

` `
`   `<font color="#339900">`// if no cache found`</font>
`   `<font color="#0000ff">`if`</font>` `<font color="#000000">`(`</font>` !cache `<font color="#000000">`)`</font>` `<font color="#000000">`{`</font>
`       cache = `<font color="#0000dd">`new`</font>` idRoutingCache`<font color="#000000">`(`</font>` file->GetCluster`<font color="#000000">`(`</font>` clusterNum `<font color="#000000">`)`</font>`.`<font color="#00aabb">`numReachableAreas`</font>` `<font color="#000000">`)`</font>`;`
`       cache->type = CACHETYPE_AREA;`
`       cache->cluster = clusterNum;`
`       cache->areaNum = areaNum;`
`       cache->startTravelTime = `<font color="#0000dd">`1`</font>`;`
`       cache->travelFlags = travelFlags;`
`       cache->prev = `<font color="#0000ff">`NULL`</font>`;`
`       cache->next = clusterCache;`
`       `<font color="#0000ff">`if`</font>` `<font color="#000000">`(`</font>` clusterCache `<font color="#000000">`)`</font>` `<font color="#000000">`{`</font>
`           clusterCache->prev = cache;`
`       `<font color="#000000">`}`</font>
`       areaCacheIndex`<font color="#000000">`[`</font>`clusterNum`<font color="#000000">`]`</font><font color="#000000">`[`</font>`clusterAreaNum`<font color="#000000">`]`</font>` = cache;`
`       UpdateAreaRoutingCache`<font color="#000000">`(`</font>` cache `<font color="#000000">`)`</font>`;`
`   `<font color="#000000">`}`</font>
`   LinkCache`<font color="#000000">`(`</font>` cache `<font color="#000000">`)`</font>`;`
`   `<font color="#0000ff">`return`</font>` cache;`
<font color="#000000">`}`</font>

There are two methods called above that also deserve some attention. UpdateAreaRoutingCache and LinkCache. We will skip UpdateAreaRoutingCache for a moment and talk about LinkCache first:

Remember in the definition of idRoutingCache:

` `
`idRoutingCache *   time_next;      `<font color="#339900">`// next in time based list`</font>
`idRoutingCache *   time_prev;      `<font color="#339900">`// previous in time based list`</font>

Because there is a cap on routing cache memory we want to track of all instances of idRoutingCache in the order they were created. LinkCache manages this doubly linked list. This allows us to delete the oldest data in the cache to make room for new data, which we will see happen later.

 UpdateAreaRoutingCache brings us to the next section, one of my favorites…

### Calculating routing caches

There are also two methods for calculating routing caches, one for each level of cache. UpdateAreaRoutingCache and UpdatePortalRoutingCache. We will look at both here.

UpdateAreaRoutingCache is called only from GetAreaRoutingCache which we just saw passes it an instance of idRoutingCache initialized with the area number for the goal area and the travel flags that may be used in calculating the routes to the area. Given this goal area UpdateAreaRoutingCache calculates the travel times from every other reachable area in the cluster to the goal area and stores them in the idRoutingCache travelTimes array. It also stores the first reachability to be used in the route from each of the areas in the reachabilities array member.

There is some initialization code before the really cool stuff happens, here are the declarations.

` `
*<font color="#339900">`/*` `============` `idAASLocal::UpdateAreaRoutingCache` `============` `*/`</font>*
<font color="#0000ff">`void`</font>` idAASLocal::`<font color="#00aabb">`UpdateAreaRoutingCache`</font><font color="#000000">`(`</font>` idRoutingCache *areaCache `<font color="#000000">`)`</font>` `<font color="#0000ff">`const`</font>` `<font color="#000000">`{`</font>
`   `<font color="#0000ff">`int`</font>` i, nextAreaNum, cluster, badTravelFlags, clusterAreaNum, numReachableAreas;`
`   `<font color="#0000ff">`unsigned`</font>` `<font color="#0000ff">`short`</font>` t, startAreaTravelTimes`<font color="#000000">`[`</font>`MAX_REACH_PER_AREA`<font color="#000000">`]`</font>`;`
`   idRoutingUpdate *updateListStart, *updateListEnd, *curUpdate, *nextUpdate;`
`   idReachability *reach;`
`   `<font color="#0000ff">`const`</font>` aasArea_t *nextArea;`

First we get the number of reachable areas within the cluster. As explained earlier we need to ensure that we have the area number that represents the area inside of the cluster, so a call to ClusterAreaNum is made to fetch that. I am not clear why the clusterAreaNum would ever be larger than the number of reachable areas, something to look into ;)

` `
` `
`   `<font color="#339900">`// number of reachable areas within this cluster`</font>
`   numReachableAreas = file->GetCluster`<font color="#000000">`(`</font>` areaCache->cluster `<font color="#000000">`)`</font>`.`<font color="#00aabb">`numReachableAreas`</font>`;`
` `
`   `<font color="#339900">`// number of the start area within the cluster`</font>
`   clusterAreaNum = ClusterAreaNum`<font color="#000000">`(`</font>` areaCache->cluster, areaCache->areaNum `<font color="#000000">`)`</font>`;`
`   `<font color="#0000ff">`if`</font>` `<font color="#000000">`(`</font>` clusterAreaNum >= numReachableAreas `<font color="#000000">`)`</font>` `<font color="#000000">`{`</font>
`       `<font color="#0000ff">`return`</font>`;`
`   `<font color="#000000">`}`</font>

Next the travelTime for the current (goal) area is initialized to the startTravelTime, which was initialized to one before being passed in. the travelTimes array will store the travel times to this area from every area in the cluster. So 1 seems reasonable for a travel time to get to the goal position in the goal area itself.

` `
`   areaCache->travelTimes`<font color="#000000">`[`</font>`clusterAreaNum`<font color="#000000">`]`</font>` = areaCache->startTravelTime;`
`   badTravelFlags = ~areaCache->travelFlags;`
`   `<font color="#0000dd">`memset`</font><font color="#000000">`(`</font>` startAreaTravelTimes, `<font color="#0000dd">`0`</font>`, `<font color="#0000dd">`sizeof`</font><font color="#000000">`(`</font>` startAreaTravelTimes `<font color="#000000">`)`</font>` `<font color="#000000">`)`</font>`;`

The algorithm will check to make sure that each reachability it visits is valid for the current request’s travel flags. This is more easily done by flipping the bits and checking if the reachability contains travel flags that are not valid. startAreaTravelTimes is an array of unsigned shorts initialized to 0’s.

Next we initialize curUpdate which is a pointer to an idRoutingUpdate object. An idRoutingUpdate object will be appointed for each area in the cluster that is reachable via the reversed reachability links stored from the goal area. It is then used to store the travel time it takes to get from the area it is created for to the goal area specified.

` `
`   `<font color="#339900">`// initialize first update`</font>
`   curUpdate = &areaUpdate`<font color="#000000">`[`</font>`clusterAreaNum`<font color="#000000">`]`</font>`;`
`   curUpdate->areaNum = areaCache->areaNum;`
`   curUpdate->areaTravelTimes = startAreaTravelTimes;`
`   curUpdate->tmpTravelTime = areaCache->startTravelTime;`
`   curUpdate->next = `<font color="#0000ff">`NULL`</font>`;`
`   curUpdate->prev = `<font color="#0000ff">`NULL`</font>`;`
`   updateListStart = curUpdate;`
`   updateListEnd = curUpdate;`

 First curUpdate is set to the address of the block of memory that was pre-allocated for it in SetupRoutingCache. This first idRoutingUpdate is created to represent the goal area itself, so its areaNum is set to the area number of the area cache we are calculating. The areaTravelTimes member is used to store travel times within the area from one reachability to another. It is set to all 0’s above. The tmpTravelTime will represent the time it takes to get from the area the routing update represents to the goal area, it is set to 1 for the goal area itself. idRoutingUpdates implement a linked list, the loop below processes updates in this list to flood the cluster calculating routing times. The last four lines above initialize that list to contain the newly initialized curUpdate as its only member. '' “The breadth first algorithm starts at the goal area and uses the reversed reachability links to flood to other areas.‿ ''

updateListStart has been initialized to the idRoutingUpdate that represents the goal area. we start flooding the cluster from this area. To do this we set curUpdate to the first update in the linked list and remove it from the list for processing. Below is that list management code.

` `
<font color="#339900">`// while there are updates in the list`</font>
`   `<font color="#0000ff">`while`</font><font color="#000000">`(`</font>` updateListStart `<font color="#000000">`)`</font>` `<font color="#000000">`{`</font>
` `
`       curUpdate = updateListStart;`
`       `<font color="#0000ff">`if`</font>` `<font color="#000000">`(`</font>` curUpdate->next `<font color="#000000">`)`</font>` `<font color="#000000">`{`</font>
`           curUpdate->next->prev = `<font color="#0000ff">`NULL`</font>`;`
`       `<font color="#000000">`}`</font>
`       `<font color="#0000ff">`else`</font>` `<font color="#000000">`{`</font>
`           updateListEnd = `<font color="#0000ff">`NULL`</font>`;`
`       `<font color="#000000">`}`</font>
`       updateListStart = curUpdate->next;`
` `
`       curUpdate->isInList = `<font color="#0000ff">`false`</font>`;`

For each area that we visit we will flood to all other reachable areas by following the reversed reachability links stored with that area:

` `
<font color="#0000ff">`for`</font>` `<font color="#000000">`(`</font>` i = `<font color="#0000dd">`0`</font>`, reach = file->GetArea`<font color="#000000">`(`</font>` curUpdate->areaNum `<font color="#000000">`)`</font>`.`<font color="#00aabb">`rev_reach`</font>`; reach; reach = reach->rev_next, i++ `<font color="#000000">`)`</font>` `<font color="#000000">`{`</font>

Before deciding that the area the reversed reachability leads to is valid for the route, we check to see if the reachability and area it leads to require travel types that the AI requesting the route isn’t capable of, if so we do not process it any further.

` `
<font color="#339900">`// if the reachability uses an undesired travel type`</font>
`   `<font color="#0000ff">`if`</font>` `<font color="#000000">`(`</font>` reach->travelType & badTravelFlags `<font color="#000000">`)`</font>` `<font color="#000000">`{`</font>
`       `<font color="#0000ff">`continue`</font>`;`
`   `<font color="#000000">`}`</font>
` `
`   `<font color="#339900">`// next area the reversed reachability leads to`</font>
`   nextAreaNum = reach->fromAreaNum;`
`   nextArea = &file->GetArea`<font color="#000000">`(`</font>` nextAreaNum `<font color="#000000">`)`</font>`;`
` `
`   `<font color="#339900">`// if traveling through the next area requires an undesired travel flag`</font>
`   `<font color="#0000ff">`if`</font>` `<font color="#000000">`(`</font>` nextArea->travelFlags & badTravelFlags `<font color="#000000">`)`</font>` `<font color="#000000">`{`</font>
`       `<font color="#0000ff">`continue`</font>`;`
`   `<font color="#000000">`}`</font>

'' “The algorithm never floods to areas outside the cluster. The algorithm does flood into cluster portals that touch the cluster.‿ ''

` `
<font color="#339900">`// get the cluster number of the area`</font>
`   cluster = nextArea->cluster;`
`   `<font color="#339900">`// don't leave the cluster, however do flood into cluster portals`</font>
`   `<font color="#0000ff">`if`</font>` `<font color="#000000">`(`</font>` cluster > `<font color="#0000dd">`0`</font>` && cluster != areaCache->cluster `<font color="#000000">`)`</font>` `<font color="#000000">`{`</font>
`       `<font color="#0000ff">`continue`</font>`;`
`   `<font color="#000000">`}`</font>

Remember, a negative cluster index would mean that the area is a cluster portal, hence the check for \> 0.

Next a couple more checks to make sure the area we are flooding to is valid:

` `
<font color="#339900">`// get the number of the area in the cluster`</font>
`   clusterAreaNum = ClusterAreaNum`<font color="#000000">`(`</font>` areaCache->cluster, nextAreaNum `<font color="#000000">`)`</font>`;`
`   `<font color="#0000ff">`if`</font>` `<font color="#000000">`(`</font>` clusterAreaNum >= numReachableAreas `<font color="#000000">`)`</font>` `<font color="#000000">`{`</font>
`       `<font color="#0000ff">`continue`</font>`;  `<font color="#339900">`// should never happen`</font>
`   `<font color="#000000">`}`</font>
`   `<font color="#0000dd">`assert`</font><font color="#000000">`(`</font>` clusterAreaNum < areaCache->size `<font color="#000000">`)`</font>`;`

If the area has passed all the checks above we will calculate the time it takes to get from the area to the goal area. To do this we add the time it takes to travel to the goal area from the area we are already in (curUpdate-\>tmpTravelTime) and the time it takes to get from where we entered the current area across the area to the start of the reachability we are flooding through and the travel time of the reachability to get to the next area. this time is stored it t:

` `
<font color="#339900">`// time already travelled plus the traveltime through the current area`</font>
<font color="#339900">`// plus the travel time of the reachability towards the next area`</font>
`t = curUpdate->tmpTravelTime + curUpdate->areaTravelTimes`<font color="#000000">`[`</font>`i`<font color="#000000">`]`</font>` + reach->travelTime;`

It usually sounds better when JP says it ;): '' “The reachabilities store a travel time, which is the time it takes the bot to travel along the reachability. These travel times are used in the routing algorithm. The areas are assumed to be nodes of a graph, but of course the areas are not points in space. It also takes time to travel through an area. These travel times through areas are also used in the routing algorithm. For each area a small table is used with travel times from every end point of a reachability that leads towards this area, to every start point of a reachability that starts in this area and leads to another area.‿ ''

Now that we know the travel time from the next area to the goal area we can check if it the fastest or first route we have found to that area:

` `
<font color="#0000ff">`if`</font>` `<font color="#000000">`(`</font>` !areaCache->travelTimes`<font color="#000000">`[`</font>`clusterAreaNum`<font color="#000000">`]`</font>` || t < areaCache->travelTimes`<font color="#000000">`[`</font>`clusterAreaNum`<font color="#000000">`]`</font>` `<font color="#000000">`)`</font>` `<font color="#000000">`{`</font>

If it is, we store that time, and the first reachability to use to get towards the goal area in the areaCache object that was passed into UpdateAreaRoutingCache to be processed:

` `
`areaCache->travelTimes`<font color="#000000">`[`</font>`clusterAreaNum`<font color="#000000">`]`</font>` = t;`
`areaCache->reachabilities`<font color="#000000">`[`</font>`clusterAreaNum`<font color="#000000">`]`</font>` = reach->number;`

We also now need to add that area to the list of areas to be flooded through, so we initialize and idRoutingUpdate for that area. Notice how it is initialized to have the tmpTravelTime set to the time that was already calculated it would take to get to the goal area and how the areaTravelTimes are set to the areaTravelTimes that were pre-calculated for the reachability way back when in CalculateAreaTravelTimes when the system was initialized.

` `
`nextUpdate = &areaUpdate`<font color="#000000">`[`</font>`clusterAreaNum`<font color="#000000">`]`</font>`;`
`nextUpdate->areaNum = nextAreaNum;`
`nextUpdate->tmpTravelTime = t;`
`nextUpdate->areaTravelTimes = reach->areaTravelTimes;`

The next step that happens is actually really cool. Sometimes a path that is the shortest isn’t always the best path to take. Paths can be weighted so that we can take more than just distance into account. A check is made to see if the area we are flooding to is near a ledge. If it is, and the AI isn’t capable of flying, this could be dangerous, so we add a penalty to this route so that if another route is available and not near a ledge, even if it is a longer route it is the better one to take.

` `
<font color="#339900">`// if we are not allowed to fly`</font>
<font color="#0000ff">`if`</font>` `<font color="#000000">`(`</font>` badTravelFlags & TFL_FLY `<font color="#000000">`)`</font>` `<font color="#000000">`{`</font>
`   `<font color="#339900">`// avoid areas near ledges`</font>
`   `<font color="#0000ff">`if`</font>` `<font color="#000000">`(`</font>` file->GetArea`<font color="#000000">`(`</font>` nextAreaNum `<font color="#000000">`)`</font>`.`<font color="#00aabb">`flags`</font>` & AREA_LEDGE `<font color="#000000">`)`</font>` `<font color="#000000">`{`</font>
`       nextUpdate->tmpTravelTime += LEDGE_TRAVELTIME_PANALTY;`
`   `<font color="#000000">`}`</font>
<font color="#000000">`}`</font>

We then add the nextUpdate to the list of idRoutingUpdates to process and head back up to the top of the loop.

` `
<font color="#0000ff">`if`</font>` `<font color="#000000">`(`</font>` !nextUpdate->isInList `<font color="#000000">`)`</font>` `<font color="#000000">`{`</font>
`   nextUpdate->next = `<font color="#0000ff">`NULL`</font>`;`
`   nextUpdate->prev = updateListEnd;`
`   `<font color="#0000ff">`if`</font>` `<font color="#000000">`(`</font>` updateListEnd `<font color="#000000">`)`</font>` `<font color="#000000">`{`</font>
`       updateListEnd->next = nextUpdate;`
`   `<font color="#000000">`}`</font>
`   `<font color="#0000ff">`else`</font>` `<font color="#000000">`{`</font>
`       updateListStart = nextUpdate;`
`   `<font color="#000000">`}`</font>
`   updateListEnd = nextUpdate;`
`   nextUpdate->isInList = `<font color="#0000ff">`true`</font>`;`
<font color="#000000">`}`</font>

Looking at the low level code detail by detail it is easy to miss what UpdateAreaRoutingCache is actually doing. Its purpose is to calculate and store the travel times from every area in the cluster to the goal area. these travel times are stored in the idRoutingCache passed to the routine. Each of the calculated travel times from an area is accompanied by the first idReachability the AI would use to take that route. Once this information is calculated it is cached for quick lookup so that future requests for the goal area do not need to recalculate the route. It does this by flooding, breadth first, through the cluster until every area that can be reached has its travel time calculated and stored in the areaCache object.

So, in its entirety, it should now be clear:

'' “The area cache is calculated with a simple breadth first routing algorithm [11]. The areas are assumed to be nodes of a graph and the reachabilities the reversed links between the nodes. The breadth first algorithm starts at the goal area and uses the reversed reachability links to flood to other areas. The algorithm never floods to areas outside the cluster. The algorithm does flood into cluster portals that touch the cluster. The reachabilities store a travel time, which is the time it takes the bot to travel along the reachability. These travel times are used in the routing algorithm. The areas are assumed to be nodes of a graph, but of course the areas are not points in space. It also takes time to travel through an area. These travel times through areas are also used in the routing algorithm. For each area a small table is used with travel times from every end point of a reachability that leads towards this area, to every start point of a reachability that starts in this area and leads to another area.‿ ''

\<TODO: UpdatePortalRoutingCache \>

### Using routing caches

At this point I have really stopped trying to add to this particular tutorial and prefer annotating methods one at a time. Much of the work that continued on from this point can be found over in [The\_annotated\_API.html the annotated API]

Other stuff that could be talked about
--------------------------------------

Obstacles Pathing: SubSampleWalkPath Debug, cool visualizations ;)

Goals: FindNearestGoal – good stuff there.

Another paper perhaps:

Navigation: WalkPathToGoal, secondary goals, blah blah blah…

